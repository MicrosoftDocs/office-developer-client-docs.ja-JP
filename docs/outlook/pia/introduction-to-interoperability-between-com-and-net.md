---
title: COM と .NET の相互運用性の概要
TOCTitle: Introduction to interoperability between COM and .NET
ms:assetid: 6b2d099a-ec6f-4099-aaf6-e61003fe5a32
ms:mtpsurl: https://msdn.microsoft.com/library/office/bb610378(v=office.15)
ms:contentKeyID: 55119776
ms.date: 07/24/2014
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: 3b19135900974c3fa379aa9f4acb18ee98a2f8c5
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/23/2019
ms.locfileid: "32360610"
---
# <a name="introduction-to-interoperability-between-com-and-net"></a><span data-ttu-id="722b9-102">COM と .NET の相互運用性の概要</span><span class="sxs-lookup"><span data-stu-id="722b9-102">Introduction to interoperability between COM and .NET</span></span>

<span data-ttu-id="722b9-103">Component Object Model (COM) と .NET 開発では、型システムおよびオブジェクト有効期間管理、インターフェイス作成、インターフェイス継承のメカニズムが大きく異なります。</span><span class="sxs-lookup"><span data-stu-id="722b9-103">The Component Object Model (COM) and .NET development have vastly different type systems and mechanisms for object lifetime management, interface creation, and interface inheritance.</span></span> 

<span data-ttu-id="722b9-104">たとえば、COM の **Variant** 型が、.NET Framework では **System.Object** データ型になります。</span><span class="sxs-lookup"><span data-stu-id="722b9-104">For example, a **Variant** type in COM is a **System.Object** data type in the .NET Framework.</span></span> <span data-ttu-id="722b9-105">オブジェクトを作成する場合、COM クライアントは [CoCreateInstance](https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) インスタンスを呼び出しますが、マネージ クライアントはマネージ プログラミング言語に組み込まれている new や New などのキーワードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="722b9-105">To create an object, a COM client calls [CoCreateInstance](https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance), whereas a managed client can use keywords such as new or New that are built in to a managed programming language.</span></span> 

<span data-ttu-id="722b9-106">COM は従来の継承をサポートせず、COM クライアントは [IUnknown](https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown) によって提供される内部参照カウントを管理してコクラスを解放しますが、マネージ クライアントは .NET Framework によって提供される共通言語ランタイム (CLR) ガベージ コレクターを利用してオブジェクトを解放します。</span><span class="sxs-lookup"><span data-stu-id="722b9-106">While COM does not support classical inheritance and a COM client manages an internal reference count provided by [IUnknown](https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown) to free a coclass, a managed client relies on the common language runtime (CLR) garbage collector provided by the .NET Framework to free an object.</span></span> 

<span data-ttu-id="722b9-107">COM と .NET 開発の間にはこのような違いがあるため、COM オブジェクト モデルに基づいてマネージ クライアントを開発するときは、これらの違いを解決するメカニズムが必要です。</span><span class="sxs-lookup"><span data-stu-id="722b9-107">Given such differences between COM and .NET development, developing a managed client on a COM object model requires a mechanism that resolves these differences.</span></span> <span data-ttu-id="722b9-108">ランタイム呼び出し可能ラッパー (RCW) は、COM とマネージ プログラミング モデルの間の透過的な通信を促進するメカニズムです。</span><span class="sxs-lookup"><span data-stu-id="722b9-108">The Runtime Callable Wrapper (RCW) is a mechanism that promotes transparent communication between COM and the managed programming model.</span></span>

<span data-ttu-id="722b9-p103">ここでは、RCW が COM とマネージ プログラミング モデルの間の通信を容易にする仕組みの概要について説明します。このトピックでは Visual Studio を使用して RCW のメカニズムを示しますが、Visual Studio が関与しない相互運用機能アセンブリを使用してマネージ クライアントを開発することもできます。</span><span class="sxs-lookup"><span data-stu-id="722b9-p103">This topic gives a high-level description of how the RCW facilitates communication between COM and the managed programming model. Note that even though this topic uses Visual Studio to illustrate the RCW mechanism, you can use an interop assembly outside of Visual Studio to develop a managed client.</span></span>

## <a name="facilitating-interoperability-the-interop-assembly-and-rcw"></a><span data-ttu-id="722b9-111">相互運用性の促進: 相互運用機能アセンブリと RCW</span><span class="sxs-lookup"><span data-stu-id="722b9-111">Facilitating interoperability: the Interop Assembly and RCW</span></span>

### <a name="compile-time"></a><span data-ttu-id="722b9-112">コンパイル時</span><span class="sxs-lookup"><span data-stu-id="722b9-112">Compile time</span></span>

<span data-ttu-id="722b9-113">相互運用機能アセンブリは、COM ベースのタイプ ライブラリにマップされ、マネージ クライアントがやり取りできるマネージ インターフェイスを定義します。</span><span class="sxs-lookup"><span data-stu-id="722b9-113">An interop assembly defines managed interfaces that map to a COM-based type library and that a managed client can interact with.</span></span> <span data-ttu-id="722b9-114">Visual Studio で相互運用機能アセンブリを使用するには、まず、対応する COM コンポーネントへの参照を追加します。</span><span class="sxs-lookup"><span data-stu-id="722b9-114">To use an interop assembly in Visual Studio, first add a reference to the corresponding COM component.</span></span> <span data-ttu-id="722b9-115">Visual Studio により、自動的に相互運用機能アセンブリのローカル コピーが生成されます。</span><span class="sxs-lookup"><span data-stu-id="722b9-115">Visual Studio will automatically generate a local copy of the interop assembly.</span></span> <span data-ttu-id="722b9-116">相互運用機能アセンブリには、1 つの名前空間が含まれていて、その名前空間には COM オブジェクト モデルの各 COM オブジェクトの同等のマネージ インターフェイスがあります。</span><span class="sxs-lookup"><span data-stu-id="722b9-116">The interop assembly contains one namespace, under which there is a managed equivalent interface of each COM object in the COM object model.</span></span> 

<span data-ttu-id="722b9-117">図 1 は、コクラス X を定義する COM タイプ ライブラリを使用しようとしているマネージ クライアントを示しています。このマネージ クライアントは、相互運用機能アセンブリで定義されているコクラス X と同等のマネージ インターフェイスであるクラス X を呼び出しています。</span><span class="sxs-lookup"><span data-stu-id="722b9-117">Figure 1 illustrates a managed client that wants to use a COM type library that defines coclass X. The managed client calls class X, which is the managed equivalent interface for coclass X, as defined in the interop assembly.</span></span> <span data-ttu-id="722b9-118">コンパイル時に、マネージ プロジェクトは相互運用機能アセンブリのクラス X についての情報でコンパイルされます。</span><span class="sxs-lookup"><span data-stu-id="722b9-118">At compile time, the managed project is compiled with information about class X from the interop assembly.</span></span>

<span data-ttu-id="722b9-119">**図 1. アンマネージ タイプ ライブラリとの相互運用性を備えた、相互運用機能アセンブリを使用してコンパイルされるマネージ アプリケーション**</span><span class="sxs-lookup"><span data-stu-id="722b9-119">**Figure 1. A managed application compiled with an interop assembly that interoperates with an unmanaged type library**</span></span>

![アンマネージ タイプ ライブラリとの相互運用性を備えた、相互運用機能アセンブリを使用してコンパイルされるマネージ アプリケーション](media/pia-unmanaged-type-library.gif)
  
<span data-ttu-id="722b9-p106">通常、タイプ ライブラリへの参照の設定さえ行えば、Visual Studio がそのタイプ ライブラリに対する相互運用機能アセンブリのコピーを生成します。同じ COM 型を記述する相互運用機能アセンブリがいくつ存在してもかまいません。ただし、タイプ ライブラリが持つことのできるプライマリ相互運用機能アセンブリ (PIA) は 1 つだけです。PIA は、タイプ ライブラリによって公開される相互運用機能アセンブリです。他の相互運用機能アセンブリとは異なり、PIA は Visual Studio で参照を追加するたびに生成されることはありません。PIA はコンピューターのグローバル アセンブリ キャッシュ (GAC) に 1 回だけインストールします。タイプ ライブラリへの参照を追加すると、Visual Studio によって PIA が自動的に読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="722b9-p106">In general, as long as you set a reference to a type library, Visual Studio generates a copy of an interop assembly for that type library. Any number of interop assemblies can exist to describe the same COM type. However, a type library can have only one Primary Interop Assembly (PIA), which is the interop assembly published by the type library. Unlike other interop assemblies, the PIA is not generated every time you add a reference in Visual Studio. Instead, you install the PIA to the global assembly cache (GAC) just once on a computer. When you add a reference to the type library, Visual Studio automatically loads the PIA.</span></span>

<span data-ttu-id="722b9-127">Outlook 用のマネージ ソリューションをプログラムする場合は、Outlook PIA を使用してください。</span><span class="sxs-lookup"><span data-stu-id="722b9-127">To program a managed solution for Outlook, you should use the Outlook PIA.</span></span> <span data-ttu-id="722b9-128">Outlook PIA からの情報をマネージ アドインに組み込むには、最初に Outlook PIA を GAC にインストールする必要があります。</span><span class="sxs-lookup"><span data-stu-id="722b9-128">To incorporate information from the Outlook PIA into a managed add-in, first you must install the Outlook PIA in the GAC.</span></span> <span data-ttu-id="722b9-129">Visual Studio を使用してマネージ プロジェクトを作成している場合は、Outlook タイプ ライブラリへの参照を追加すると、Visual Studio が PIA を読み込みます。</span><span class="sxs-lookup"><span data-stu-id="722b9-129">If you are using Visual Studio to create the managed project, after adding a reference to the Outlook type library, Visual Studio loads the PIA.</span></span> <span data-ttu-id="722b9-130">オブジェクト ブラウザーでは、名前空間 Microsoft.Office.Interop.Outlook の下に、Outlook オブジェクト モデルでのオブジェクトに対応する名前のマネージ インターフェイスが表示されます。</span><span class="sxs-lookup"><span data-stu-id="722b9-130">In the object browser, under the namespace Microsoft.Office.Interop.Outlook, you can see managed interfaces that have names corresponding to objects in the Outlook object model.</span></span> <span data-ttu-id="722b9-131">たとえば、Account インターフェイスは Outlook オブジェクト モデルの **Account** オブジェクトに対応します。</span><span class="sxs-lookup"><span data-stu-id="722b9-131">For example, the Account interface corresponds to the **Account** object in the Outlook object model.</span></span> <span data-ttu-id="722b9-132">マネージ プロジェクトをコンパイルするときに、この情報が実行可能ファイルに組み込まれます。</span><span class="sxs-lookup"><span data-stu-id="722b9-132">When you compile the managed project, this information is incorporated in your executable.</span></span>

### <a name="run-time"></a><span data-ttu-id="722b9-133">実行時</span><span class="sxs-lookup"><span data-stu-id="722b9-133">Run time</span></span>

<span data-ttu-id="722b9-p108">実行時に、.NET Framework CLR は、相互運用機能アセンブリによって提供された情報を使用して、マネージ クライアントが対話するコクラスごとに RCW を作成します。クライアントがコクラスから取得したインターフェイスの数にかかわらず、ランタイムが作成する RCW はコクラスごとに 1 つだけであることに注意してください。RCW は、COM のコクラスをラップする .NET Framework クラスの型です。RCW は、コクラスのインスタンスを追跡し、クライアントで RCW が不要になったときにのみインスタンスへの参照を解放します。これにより、マネージ クライアントは、COM でアンマネージ クライアントが行うような方法で、オブジェクトの有効期間を管理する必要がなくなります。</span><span class="sxs-lookup"><span data-stu-id="722b9-p108">At run time, with the information provided by an interop assembly, the .NET Framework CLR creates an RCW for each coclass the managed client interacts with. Note that the runtime creates only one RCW for each coclass, regardless of how many interfaces the client has obtained from the coclass. The RCW is a .NET Framework class type that wraps around the COM coclass. The RCW keeps track of the instances of the coclass and releases references to them only when the client no longer needs the RCW. This way, a managed client does not have to manage the lifetime of an object the way an unmanaged client would under COM.</span></span>

<span data-ttu-id="722b9-p109">図 2 に示す RCW は、実行時にマネージ クライアントからの API 呼び出しを途中で受信し、相互運用機能アセンブリからの情報を使用して、呼び出しを COM コクラスの対応する API に透過的にマップします。このときに行われる処理について次に説明します。</span><span class="sxs-lookup"><span data-stu-id="722b9-p109">Figure 2 illustrates an RCW intercepting an API call from a managed client at run time, and using information from the interop assembly, transparently mapping the call to the corresponding API in the COM coclass. The following process describes how this happens:</span></span>

1.  <span data-ttu-id="722b9-141">マネージ クライアントは、COM タイプ ライブラリに対する相互運用機能アセンブリでの定義に従って、クラス X' のメソッド A' を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="722b9-141">The managed client calls method A' of class X' as defined in the interop assembly for a COM type library.</span></span>

2.  <span data-ttu-id="722b9-142">クラス X' に対する RCW がまだ存在しない場合, .NET Framework ランタイムは相互運用機能アセンブリからの情報を使用して、クラス X' 用の RCW を作成します。</span><span class="sxs-lookup"><span data-stu-id="722b9-142">If an RCW does not yet exist for class X', the .NET Framework runtime uses information from the interop assembly and creates an RCW for class X'.</span></span>

3.  <span data-ttu-id="722b9-143">RCW は、メソッド A' の呼び出しを途中で受信し、引数を対応する COM 型に変換して、COM タイプ ライブラリでの定義に従ってコクラス X のメソッド A を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="722b9-143">The RCW intercepts the call to method A', translates the arguments into corresponding COM types, and invokes method A of coclass X as defined in the COM type library.</span></span>

<span data-ttu-id="722b9-144">**図 2. マネージ実行可能ファイルからの呼び出しを途中で受信してアンマネージ タイプ ライブラリのコクラスにマップする RCW**</span><span class="sxs-lookup"><span data-stu-id="722b9-144">**Figure 2. An RCW intercepts a call from a managed executable and maps it to a coclass in an unmanaged type library**</span></span>

![マネージ実行可能ファイルからの呼び出しを途中で受信してアンマネージ タイプ ライブラリのコクラスにマップする RCW](media/pia-unmanaged-type-library-2.gif)
  

## <a name="see-also"></a><span data-ttu-id="722b9-146">関連項目</span><span class="sxs-lookup"><span data-stu-id="722b9-146">See also</span></span>

- [<span data-ttu-id="722b9-147">Outlook PIA を使用する理由</span><span class="sxs-lookup"><span data-stu-id="722b9-147">Why use the Outlook PIA</span></span>](why-use-the-outlook-pia.md)
- [<span data-ttu-id="722b9-148">Outlook PIA のインストールと参照</span><span class="sxs-lookup"><span data-stu-id="722b9-148">Installing and referencing the Outlook PIA</span></span>](installing-and-referencing-the-outlook-pia.md)


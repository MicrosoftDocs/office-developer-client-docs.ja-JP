---
title: イベント ハンドラーの共同作業の方法
TOCTitle: How event handlers work together
ms:assetid: 02122824-881e-0bb8-cba1-c963024790ae
ms:mtpsurl: https://msdn.microsoft.com/library/JJ248788(v=office.15)
ms:contentKeyID: 48542951
ms.date: 09/18/2015
mtps_version: v=office.15
ms.openlocfilehash: 294f1f87de85d8a8c54aeeb3ef74181cef755d32
ms.sourcegitcommit: 45feafb3b55de0402dddf5548c0c1c43a0eabafd
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/07/2018
ms.locfileid: "26026366"
---
# <a name="how-event-handlers-work-together"></a><span data-ttu-id="a43f8-102">イベント ハンドラーの共同作業の方法</span><span class="sxs-lookup"><span data-stu-id="a43f8-102">How event handlers work together</span></span>

<span data-ttu-id="a43f8-103">**適用されます**Access 2013、Office 2013。</span><span class="sxs-lookup"><span data-stu-id="a43f8-103">**Applies to**: Access 2013, Office 2013</span></span>

<span data-ttu-id="a43f8-p101">Visual Basic でプログラミングするのでない限り、 **Connection** イベントと **Recordset** イベントのイベント ハンドラーは、それらのイベントを実際に処理するかどうかにかかわらず、すべて実装する必要があります。実装に必要な作業量は、使用するプログラミング言語によって異なります。詳細については、「 [ADO イベントのインスタンス化 (言語別)](https://docs.microsoft.com/office/client-developer/access/desktop-database-reference/ado-event-instantiation-by-language-ado)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a43f8-p101">Unless you are programming in Visual Basic, all event handlers for **Connection** and **Recordset** events must be implemented, regardless of whether you actually process all of the events. The amount of implementation work you have to do depends on your programming language. For more information, see [ADO Event Instantiation by Language](https://docs.microsoft.com/office/client-developer/access/desktop-database-reference/ado-event-instantiation-by-language-ado).</span></span>

## <a name="paired-event-handlers"></a><span data-ttu-id="a43f8-107">対のイベント ハンドラー</span><span class="sxs-lookup"><span data-stu-id="a43f8-107">Paired event handlers</span></span>

<span data-ttu-id="a43f8-p102">各 Will イベント ハンドラーには、関連する Complete イベント ハンドラーがあります。たとえば、アプリケーションでフィールドの値を変更すると、 **WillChangeField** イベント ハンドラーが呼び出されます。変更を受け入れてもよい場合、アプリケーションで **adStatus** パラメーターを変更しないようにすると、操作が実行されます。操作が終了すると、 **FieldChangeComplete** イベントが操作の完了をアプリケーションに通知します。操作が正常に完了していれば、 **adStatus** に **adStatusOK** が格納されます。それ以外の場合は、 **adStatus** に **adStatusErrorsOccurred** が格納されるので、この場合は、アプリケーションで **Error** オブジェクトを調べて、エラーの原因を知る必要があります。</span><span class="sxs-lookup"><span data-stu-id="a43f8-p102">Each Will event handler has an associated Complete event handler. For example, when your application changes the value of a field, the **WillChangeField** event handler is called. If the change is acceptable, your application leaves the **adStatus** parameter unchanged and the operation is performed. When the operation completes, a **FieldChangeComplete** event notifies your application that the operation has finished. If it completed successfully, **adStatus** contains **adStatusOK**; otherwise, **adStatus** contains **adStatusErrorsOccurred** and you must check the **Error** object to determine the cause of the error.</span></span>

<span data-ttu-id="a43f8-p103">**WillChangeField** が呼び出されたときに、その変更操作が行われないようにする場合もあります。そのような場合は、 **adStatus** を **adStatusCancel** に設定します。操作はキャンセルされ、 **FieldChangeComplete** イベントは値 **adStatusErrorsOccurred** が設定された **adStatus** を受け取ります。操作がキャンセルされたことを **FieldChangeComplete** ハンドラーが判断できるように、 **Error** オブジェクトには **adErrOperationCancelled** が格納されています。ただし、 **adStatus** を **adStatusCancel** に設定しても、プロシージャのエントリでパラメーターが **adStatusCantDeny** に設定されていると、キャンセル操作は無効になるので、変更を行う前に **adStatus** の値を確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a43f8-p103">When **WillChangeField** is called, you might determine that the change should not be made. In that case, set **adStatus** to **adStatusCancel**. The operation is canceled and the **FieldChangeComplete** event receives an **adStatus** value of **adStatusErrorsOccurred**. The **Error** object contains **adErrOperationCancelled** so that your **FieldChangeComplete** handler knows that the operation was canceled. However, you need to check the value of the **adStatus** parameter before changing it, because setting **adStatus** to **adStatusCancel** has no effect if the parameter was set to **adStatusCantDeny** on entry to the procedure.</span></span>

<span data-ttu-id="a43f8-p104">1 つの操作から複数のイベントが発生することもあります。たとえば、Recordset オブジェクトには、Field 変更と Record 変更に関する対をなすイベントがあります。アプリケーションで Field の値を変更すると、WillChangeField イベント ハンドラーが呼び出されます。WillChangeField イベント ハンドラーで、その操作を続行できると決定した場合、さらに WillChangeRecord イベント ハンドラーが起動します。WillChangeRecord イベント ハンドラーでもイベントの続行が許可されると、変更操作が実行され、FieldChangeComplete イベント ハンドラーと RecordChangeComplete イベント ハンドラーが呼び出されます。個々の操作に対する Will イベント ハンドラー群の呼び出し順序は定義されていないので、ハンドラーの特定の呼び出し順序に依存するコードは記述しないでください。</span><span class="sxs-lookup"><span data-stu-id="a43f8-p104">Sometimes an operation can raise more than one event. For example, the **Recordset** object has paired events for **Field** changes and **Record** changes. When your application changes the value of a **Field**, the **WillChangeField** event handler is called. If it determines that the operation can continue, the **WillChangeRecord** event handler is also raised. If this handler also allows the event to continue, the change is made and the **FieldChangeComplete** and **RecordChangeComplete** event handlers are called. The order in which the Will event handlers for a particular operation are called is not defined, so you should avoid writing code that depends on calling handlers in a particular sequence.</span></span>

<span data-ttu-id="a43f8-p105">複数の Will イベントが発生する状況では、そのうちの 1 つのイベントで、保留中の操作が取り消される可能性があります。たとえば、アプリケーションで **Field** の値を変更する場合、通常は、 **WillChangeField** イベント ハンドラーと **WillChangeRecord** イベント ハンドラーの両方が呼び出されます。しかし、最初に呼び出されたイベント ハンドラーで操作が取り消されると、それと対の Complete ハンドラーが **adStatusOperationCancelled** で呼び出されます。2 つ目のハンドラーは呼び出されません。これに対し、最初のイベント ハンドラーでイベントの続行が許可されると、2 つ目のイベント ハンドラーも呼びさ出されます。2 つ目のハンドラーで操作が取り消されると、前の例に示したように、対になる Complete イベントが 2 つとも呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="a43f8-p105">In instances when multiple Will events are raised, one of the events might cancel the pending operation. For example, when your application changes the value of a **Field**, both **WillChangeField** and **WillChangeRecord** event handlers would normally be called. However, if the operation is canceled in the first event handler, its associated Complete handler is immediately called with **adStatusOperationCancelled**. The second handler is never called. If, however, the first event handler allows the event to proceed, the other event handler will be called. If it then cancels the operation, both Complete events will be called as in the earlier examples.</span></span>

## <a name="unpaired-event-handlers"></a><span data-ttu-id="a43f8-130">対になっていないイベント ハンドラー</span><span class="sxs-lookup"><span data-stu-id="a43f8-130">Unpaired event handlers</span></span>

<span data-ttu-id="a43f8-131">としてイベントに渡されるステータスが**adStatusCantDeny**ではありません、*状態*パラメーターに**adStatusUnwantedEvent**を返すことによって任意のイベントのイベント通知を無効にできます。</span><span class="sxs-lookup"><span data-stu-id="a43f8-131">As long as the status passed to the event is not **adStatusCantDeny**, you can turn off event notifications for any event by returning **adStatusUnwantedEvent** in the *Status* parameter.</span></span> <span data-ttu-id="a43f8-132">たとえば、完了イベント ハンドラーが呼び出されると最初に、 **adStatusUnwantedEvent**を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="a43f8-132">For example, when your Complete event handler is called the first time, you can return **adStatusUnwantedEvent**.</span></span> <span data-ttu-id="a43f8-133">その後 Will イベントのみが表示されます。</span><span class="sxs-lookup"><span data-stu-id="a43f8-133">You will subsequently receive only Will events.</span></span> <span data-ttu-id="a43f8-134">ただし、理由の 1 つ以上のいくつかのイベントは発生します。</span><span class="sxs-lookup"><span data-stu-id="a43f8-134">However, some events can be triggered for more than one reason.</span></span> <span data-ttu-id="a43f8-135">その場合は、イベントは、 *"理由*"パラメーターがあります。</span><span class="sxs-lookup"><span data-stu-id="a43f8-135">In that case, the event will have a *Reason* parameter.</span></span> <span data-ttu-id="a43f8-136">**AdStatusUnwantedEvent**を返すとき、その特定の理由が発生したときにのみイベント通知の受信を停止します。</span><span class="sxs-lookup"><span data-stu-id="a43f8-136">When you return **adStatusUnwantedEvent**, you will stop receiving notifications for that event only when they occur for that particular reason.</span></span> <span data-ttu-id="a43f8-137">つまり、イベントが発生することを理由の通知が表示されます可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a43f8-137">In other words, you will potentially receive notification for each possible reason that the event could be triggered.</span></span>

<span data-ttu-id="a43f8-p107">単一の Will イベント ハンドラーは、操作に使用するパラメーターの検証に便利です。このイベント ハンドラーで、操作パラメーターの変更または操作のキャンセルを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="a43f8-p107">Single Will event handlers can be useful when you want to examine the parameters that will be used in an operation. You can modify those operation parameters or cancel the operation.</span></span>

<span data-ttu-id="a43f8-p108">一方、Complete イベントによる通知を有効のままにしておく方法もあります。最初の Will イベント ハンドラーが呼び出されたときに、 **adStatusUnwantedEvent** を返します。それ以降は、Complete イベントのみを受け取るようになります。</span><span class="sxs-lookup"><span data-stu-id="a43f8-p108">Alternatively, leave Complete event notification enabled. When your first Will event handler is called, return **adStatusUnwantedEvent**. You will subsequently receive only Complete events.</span></span>

<span data-ttu-id="a43f8-p109">単一の Complete イベント ハンドラーは、非同期操作の管理に便利です。非同期操作には、それぞれ適切な Complete イベントが関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="a43f8-p109">Single Complete event handlers can be useful for managing asynchronous operations. Each asynchronous operation has an appropriate Complete event.</span></span>

<span data-ttu-id="a43f8-145">たとえば、非常に大きな [Recordset](recordset-object-ado.md) オブジェクトへのデータの格納には時間がかかることがあります。</span><span class="sxs-lookup"><span data-stu-id="a43f8-145">For example, it can take a long time to populate a large [Recordset](recordset-object-ado.md) object.</span></span> <span data-ttu-id="a43f8-146">アプリケーションが適切に書き込まれる場合、操作を開始し、他の処理を続行できます。</span><span class="sxs-lookup"><span data-stu-id="a43f8-146">If your application is appropriately written, you can start a operation and continue with other processing.</span></span> <span data-ttu-id="a43f8-147">**Recordset** へのデータ格納が完了したことは、 **ExecuteComplete** イベントの通知によって知るようにします。</span><span class="sxs-lookup"><span data-stu-id="a43f8-147">You will eventually be notified when the **Recordset** is populated by an **ExecuteComplete** event.</span></span>

## <a name="single-event-handlers-and-multiple-objects"></a><span data-ttu-id="a43f8-148">1 つのイベント ハンドラーと複数のオブジェクト</span><span class="sxs-lookup"><span data-stu-id="a43f8-148">Single event handlers and multiple objects</span></span>

<span data-ttu-id="a43f8-p111">Microsoft Visual C++ のような柔軟性のあるプログラミング言語では、複数のオブジェクトからのイベントを 1 つのイベント ハンドラーで処理することができます。たとえば、複数の **Connection** オブジェクトからのイベントを 1 つの **Disconnect** イベント ハンドラーで処理できます。接続の 1 つが終了すると、 **Disconnect** イベント ハンドラーが呼び出されます。イベント ハンドラーのオブジェクト パラメーターが対応する **Connection** オブジェクトに設定されるため、どの接続がイベントを発生させたかを判別できます。</span><span class="sxs-lookup"><span data-stu-id="a43f8-p111">The flexibility of a programming language like Microsoft Visual C++ enables you to have one event handler process events from multiple objects. For example, you could have one **Disconnect** event handler process events from several **Connection** objects. If one of the connections ended, the **Disconnect** event handler would be called. You could tell which connection caused the event because the event-handler object parameter would be set to the corresponding **Connection** object.</span></span>

> [!NOTE]
> <span data-ttu-id="a43f8-153">[!メモ] Visual Basic では 1 つのイベント ハンドラーに 1 つのオブジェクトしか関連付けできないため、この手法は Visual Basic では使用できません。</span><span class="sxs-lookup"><span data-stu-id="a43f8-153">This technique cannot be used in Visual Basic because that language can correlate only one object to an event handler.</span></span>


